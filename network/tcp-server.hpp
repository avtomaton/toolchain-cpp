#ifndef TCP_SERVER_H
#define TCP_SERVER_H

#include <string>
#include <atomic>
#include <memory>
#include <mutex>
#include <thread>
#include <fstream>
#include <list>
#include <functional>
#include <boost/asio.hpp>

class TcpSession
{
public:
	explicit TcpSession(std::shared_ptr<boost::asio::io_service> io_service_);
	virtual ~TcpSession();

	///---------------
	///----события----
	///---------------

	/**
	 * @brief
	 * Вызывается каждый раз, когда из сетевого соединения прочитана очередная порция данных,
	 * и помещена в буфер, который был указан в методе on_request_buffer().
	 * Класс - потомок должен переопределить метод в секции private.
	 * @param buffer [in] указатель на полученные из сокета данные.
	 * @param octets [in] размер полученных данных, а байтах.
	 */
	virtual void on_read_socket(const void * buffer, size_t octets);

	virtual void on_after_send();

	virtual void on_after_read();

	///------------------------
	///----публичные методы----
	///------------------------

	virtual void on_debug_msg(const std::string &msg);

	void set_timeout(uint64_t _timeout_ms);

	/**
	 * @brief
	 * Завершение работы рабочего потока и освобождение ресурсов. Предназначен
	 * для вызова в деструкторах производных классов.
	 */
	void shutdown();

	/**
	 * @brief
	 * Отправляет через сетевое соединение порцию данных.
	 * Возвращает управление, не дожидаясь отправки данных. Область памяти, содержащая
	 * данные, должна существовать и содержать корректные данные до момента, когда
	 * будет вызван обработчик события завершения асинхронной передачи данных.
	 * Предназначен для вызова методами классов-потомков в том же потоке, в
	 * котором работает главный цикл.
	 * Не предназначен для вызова вне методов классов-потомков и из другого потока.
	 * @param buffer [in] Указатель на данные, которые необходимо передать.
	 * @param octets [in] Размер данных для передачи, байт.
	 */
	bool async_send_data();
	bool async_send_data(const std::string &data);

	/**
	 * @brief
	 * Закрывает сессию сетевого соединения.
	 */
	void close_session();

	/**
	* @brief
	* Перезапускает таймер, отсчитывающий таймаут неактивности соединения.
	*/
	void reset_connection_timeout();

	/**
	* @brief
	* Запускает асинхронную операцию ожидания поступления данных через соединение.
	* Получает у класса-потомка буфер для данных с помощью метода on_request_buffer(),
	* после чего стартует асинхронную операцию чтения и возвращает управление.
	* Когда данные поступят, они будут помещены в указанный буфер, после чего будет вызван
	* метод on_read_socket().
	*/
	void open_async_read();

	void open_async_accept(
			boost::asio::ip::tcp::acceptor &acceptor,
			std::function<void(const boost::system::error_code&)> on_accept);

	bool is_close() const;

private:
	///------------------------
	///----хэндлеры------------
	///------------------------

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события чтения порции данных из сокета.
	 * @param ec [in] Код ошибки.
	 * @param octets_transferred [in] Количество байт данных, прочитанных
	 * из сокета. Данные находятся в буфере, который был указан при вызове
	 * метода асинхронного чтения данных.
	 * Документация: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html
	 */
	void asio_read_handler(const boost::system::error_code & ec,
						   size_t octets_received);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события записи порции данных в сокет.
	 * @param ec [in] Код ошибки.
	 * @param octets_transferred [in] Количество байт данных, записанных в сокет.
	 * @param octets_required [in] Количество байт данных, переданных методу асинхронной
	 * записи данных в сокет.
	 * Документация: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html
	 */
	void asio_write_handler(const boost::system::error_code & ec,
							size_t octets_transferred,
							size_t octets_required);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события таймаута таймера активности соединения.
	 * @param ec [in] Код ошибки.
	 */
	void asio_iddle_timer_handler(const boost::system::error_code & ec);

	///------------------------
	///----закрытые методы-----
	///------------------------

	/**
	 * @brief
	 * Отправляет через сетевое соединение порцию данных.
	 * Возвращает управление, когда все данные будут переданы сетевому стеку.
	 * В случае ошибки генерирует исключение.
	 * Предназначен для вызова методами классов-потомков в том же потоке, в
	 * котором работает главный цикл.
	 * Не предназначен для вызова вне методов классов-потомков и из другого потока.
	 * @param buffer [in] Указатель на данные, которые необходимо передать.
	 * @param count_in_bytes [in] Размер данных для передачи, байт.
	 */
	void send_data(const void * buffer, size_t octets);
	void send_data(const std::string &data);

protected:
	///------------------------
	///----закрытые методы-----
	///------------------------

	/**
	* @brief
	* Подготавливает ресурсы к сессии сетевого соединения.
	*/
	void setup_session_resources();

	/**
	* @brief
	* Осбобождает ресурсы после сессии сетевого соединения.
	*/
	void cleanup_session_resources();

protected:
	int64_t iddle_timeout_ms;
	std::atomic<bool> shutdown_flag;
	std::atomic<bool> is_close_flag;
	std::atomic<bool> async_send_flag; // true, если идёт отправка

	const size_t READ_BUFFER_SIZE = 8192;
	std::vector<uint8_t> read_buffer;
	const size_t SEND_PACKAGE_SIZE = 512;
	std::vector<uint8_t> send_buffer;
	size_t send_buffer_cursor = 0;

	std::shared_ptr<boost::asio::ip::tcp::socket> socket;
	std::shared_ptr<boost::asio::io_service> io_service;
	std::unique_ptr<boost::asio::deadline_timer> iddle_timer;
};


class TcpServer
{
public:
	/**
	 * @brief
	 * Конструктор для режима хоста.
	 * @param _listen_port [in] Номер порта для ожидания подключения клиента.
	 */
	explicit TcpServer(uint16_t _listen_port);

	/**
	 * @brief
	 * Деструктор класса.
	 */
	virtual ~TcpServer();

	/**
	 * @brief
	 * Старт сетевого подключения.
	 * Устанавливает соединение с указанным хостом при работе в режиме клиента, или ожидает
	 * подключения клиента на указанном порту при работе в режиме хоста.
	 * После установления соединения начинает работу цикл чтения порций приходящих через сетевое
	 * соединение данных, запись их в указанный файл, и передача их переопределеному методу
	 * класса-потомка.
	 * Цикл чтения данных работает, и вызов переопределенных методов происходит в отдельном потоке.
	 * При завершении или разрыве соединения, если не активирован режим автоматического установления
	 * повторного соединения, цикл завершает работу. Если активирован режим повторного соединения,
	 * предпринимается попытка повторного подключения в режиме клиента, или переход в режим ожидания
	 * подключения в режиме хоста.
	 * В процессе выполнения метод запускает отдельный поток, и возвращает управление вызвавшему
	 * коду.
	 * Для ожидания завершения работы сетевого соединения предназначен метод join().
	 * Перед вызовом метода можно задать имя файла для записи входящих данных,
	 * установить режим повторного установления соединения (если необходимо),
	 * установить таймаут автоматического разрыва соединения при отсутствии передачи или
	 * приема данных (значение по умолчанию 0 - соединение поддерживается бесконечно долго).
	 */
	virtual void run_async();

	/**
	 * @brief
	 * Старт сетевого подключения.
	 * Устанавливает соединение с указанным хостом при работе в режиме клиента, или ожидает
	 * подключения клиента на указанном порту при работе в режиме хоста.
	 * После установления соединения начинает работу цикл чтения порций приходящих через сетевое
	 * соединение данных, запись их в указанный файл, и передача их переопределеному методу
	 * класса-потомка.
	 * При завершении или разрыве соединения, если не активирован режим автоматического
	 * установления повторного соединения, цикл завершает работу. Если активирован режим
	 * повторного соединения, предпринимается попытка повторного подключения в режиме клиента,
	 * или переход в режим ожидания подключения в режиме хоста.
	 * Метод возвращает управление, когда цикл чтения данных из сетевого соединения звершит работу.
	 * Перед вызовом метода можно задать имя файла для записи входящих данных,
	 * установить режим повторного установления соединения (если необходимо),
	 * установить таймаут автоматического разрыва соединения при отсутствии передачи или
	 * приема данных (значение по умолчанию 0 - соединение поддерживается бесконечно долго).
	 */
	virtual void run();

	/**
	 * @brief
	 * Сообщает экземпляру класса о необходимости остановить работу.
	 * Не гарантирует остановки после возвращения управления.
	 * Остановки работы необходимо дождаться с помощью метода join().
	 * Не предназначен для вызова из обработчика системных сигналов SIGINT, SIGTERM при
	 * использовании метода run(), но может использоваться таким образом
	 * при использовании метода run_async().
	 * Не предназначен для вызова в том же потоке, в котором выполнен вызов run().
	 * В этом случае возможна бесконечная блокировка выполнения.
	 */
	virtual void stop();

	/**
	 * @brief
	 * Блокирует вызвавший поток. Возвращает управление после того, как объект класса
	 * завершит работу цикла чтения входящих данных, закроет сетевое соединение и
	 * уничтожит рабочий поток.
	 */
	virtual void join();

	/**
	 * @brief
	 * Подготовка к повторному запуску.
	 * Сбрасывает внутренние флаги.
	 * Используется перед повторным запуском run() или run_async().
	 * Не заменяет метод stop(). Остановка работающего в асинхронном режиме экземпляра
	 * класса должна быть выполнена методом stop(), с последующим ожиданием
	 * завершения работы методом join().
	 * Не влияет на следющие установки:
	 * - файл для записи лога входящих данных;
	 * - режим повторного утсановления соединения.
	 */
	virtual void reset();

	/**
	 * @brief
	 * Проверяет, находится ли объект класса в рабочем состоянии, или завершил работу.
	 * @return Состояние объекта класса: true - работает; false - работа завершена.
	 */
	virtual bool is_run() const;

	virtual void on_debug_msg(const std::string &msg);

protected:
	/**
	 * @brief
	 * Вызывается каждый раз, когда из сетевого соединения прочитана очередная порция данных,
	 * и помещена в буфер, который был указан в методе on_request_buffer().
	 * Класс - потомок должен переопределить метод в секции private.
	 * @param buffer [in] указатель на полученные из сокета данные.
	 * @param octets [in] размер полученных данных, а байтах.
	 */
	virtual void on_read_socket(const void * buffer, size_t octets);

	void asio_accept_handler(const boost::system::error_code & ec);

	/**
	 * @brief
	 * Завершение работы рабочего потока и освобождение ресурсов. Предназначен
	 * для вызова в деструкторах производных классов.
	 */
	void shutdown();

	/**
	* Основной цикл рабочего потока.
	* Устанавливает соединение в режиме клиента с указанным хостом либо
	* ожидает и устанавливает соединение с клиентом на указанном порту в режиме хоста,
	* запускает цикл чтения входящих данных из сокета.
	* Если установлен режим повторного установления соединения, после закрытия
	* текущего соединения или ошибки сети пытается установить новое подключение или
	* переходит в режим ожидания подключения клиента.
	*/
	void main_loop();

	/**
	* @brief
	* Метод для запуска в отдельном рабочем потоке. Вызывает main_loop() и
	* перехватывает исключения.
	*/
	void async_loop();

	virtual std::shared_ptr<TcpSession> create_session() = 0;

	void init();

	void close_server();

	void remove_close_sessions();

protected:
	/**
	 * @brief
	 * Пауза перед повторным установлением соединения, миллисекунд.
	 * Предотвращает загрузку ядра процессора при проблемах сетевого стека.
	 */
	const int64_t CPU_PREVENT_OVERLOAD_TIMEOUT_MS = 100;

	uint16_t port;

	std::atomic<bool> thread_is_run;
	std::atomic<bool> server_is_run;
	std::atomic<bool> is_clean_to_run;
	std::atomic<bool> shutdown_flag;
	std::atomic<bool> full_stop_flag;

	std::unique_ptr<std::thread> async_thread;

	std::shared_ptr<boost::asio::io_service> io_service;
	std::shared_ptr<boost::asio::ip::tcp::endpoint> endpoint;
	std::shared_ptr<boost::asio::ip::tcp::acceptor> acceptor;

	std::vector<std::shared_ptr<TcpSession>> sessions;
	std::shared_ptr<TcpSession> new_session;

private:
	mutable std::mutex close_server_mutex;
};

#endif
