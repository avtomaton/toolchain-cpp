#ifndef NETWORKCONNECTION_HPP
#define NETWORKCONNECTION_HPP

#include <string>
#include <atomic>
#include <memory>
#include <mutex>
#include <thread>
#include <fstream>
#include <list>
#include <boost/asio.hpp>

#include "asio-timer.hpp"


/**
 * @brief
 *
 * === ! ПРОИЗВОДНЫЙ КЛАСС ОБЯЗАН В ДЕСТРУКТОРЕ ВЫЗВАТЬ МЕТОД shutdown()                 ! ===
 * === ! ДЛЯ КОРРЕКТНОЙ ОСТАНОВКИ РАБОЧЕГО ПОТОКА ДО НАЧАЛА РАЗРУШЕНИЯ ЭКЗЕМПЛЯРА КЛАССА ! ===
 *
 * Базовый класс, обеспечивающий для классов-потомков функциональность:
 * - установление TCP соединения с удаленным хостом в режиме клиента, или ожидание
 * подключения клиента в режиме хоста и установление TCP соединения с клиентом;
 * - работу цикла чтения данных из сетевого соединения;
 * - запись (логирование) поступивших из сетевого соединения данных в файл;
 * - передачу порции прочитанных из сетевого соединения данных классу-потомку с помощью
 * вызова переопределенного метода;
 * - безопасную остановку работы сетевого соединения из другого потока;
 * - автоматическое повторное установление соединения или автоматический переход в режим ожидания
 * соединения при разрыве сетевого соединения.
 * Известные проблемы:
 * Метод stop() нельзя вызывать из обработчика системных сигналов (SIGINT, SIGTERM) при
 * использовании метода run(). Обработка сигналов (SIGINT, SIGTERM) классом работает только при
 * использовании метода run() в главном потоке процесса. Режим обработки сигналов не совместим
 * с использованием метода run_async(), но при использовании метода run_async() метод
 * stop() можно вызывать из стандартного обработчика сигналов.
 * При работе в синхронном режиме (запуск методом run() в главном потоке процесса), рекомендуется
 * инициализировать режим перехвата системных сигналов классом (параметр handle_signals
 * конструктора).
 *
 * Способ использования класса 1:
 *
 * InheritedClass conn("127.0.0.1", 8888);
 * conn.set_handle_signals_mode(true); // Режим перехвата системных сигналов.
 * conn.set_reconnection_mode(true); // Автоматический реконнект при разрыве соединения.
 * conn.set_timeout(30000); // Время неактивности соединения до разрыва, мс.
 * conn.set_raw_log_file("raw-log.dat");
 * conn.run();
 * <--- Выполнение продолжится, когда соединение будет закрыто (без режима автореконнекта),
 * или будет прервано системным сигналом.
 * conn.reset(); // Возможен повторный запуск.
 * conn.run();
 *
 *
 * Способ использования класса 2:
 *
 * InheritedClass conn("127.0.0.1", 8888);
 * conn.set_reconnection_mode(true); // Автоматический реконнект при разрыве соединения.
 * conn.set_timeout(30000); // Время неактивности соединения до разрыва, мс.
 * conn.set_raw_log_file("raw-log.dat");
 * conn.run_async(); // Асинхронный старт в отдельном потоке.
 * <--- Выполнение кода продолжится немедленно.
 *
 * conn.stop(); // Можно вызывать из обработчика сигналов.
 * conn.join(); // Ожидание завершения асинхронной работы.
 * conn.reset(); // Возможен повторный запуск.
 * conn.run_async();
 *
 * При работе в асинхронном режиме можно проверять, работает ли соединение, проверяя состояния
 * is_run() и is_connected(). В случае необходимости перезапуск выполняется так:
 * conn.join();
 * conn.reset();
 * conn.run_async();
 */
class NetworkConnection
{
public:
	/**
	 * @brief
	 * Конструктор для режима хоста.
	 * @param _listen_port [in] Номер порта для ожидания подключения клиента.
	 */
	explicit NetworkConnection(uint16_t _listen_port);

	/**
	 * @brief
	 * Конструктор для режима клиента.
	 * @param _remote_ip [in] IP-адрес удаленного хоста.
	 * @param _remote_port [in] Порт удаленного хоста.
	 */
	NetworkConnection(const std::string & _remote_ip,
	                  uint16_t _remote_port);

	/**
	 * @brief
	 * Деструктор класса.
	 */
	virtual ~NetworkConnection();

	/**
	 * @brief
	 * Старт сетевого подключения.
	 * Устанавливает соединение с указанным хостом при работе в режиме клиента, или ожидает
	 * подключения клиента на указанном порту при работе в режиме хоста.
	 * После установления соединения начинает работу цикл чтения порций приходящих через сетевое
	 * соединение данных, запись их в указанный файл, и передача их переопределеному методу
	 * класса-потомка.
	 * Цикл чтения данных работает, и вызов переопределенных методов происходит в отдельном потоке.
	 * При завершении или разрыве соединения, если не активирован режим автоматического установления
	 * повторного соединения, цикл завершает работу. Если активирован режим повторного соединения,
	 * предпринимается попытка повторного подключения в режиме клиента, или переход в режим ожидания
	 * подключения в режиме хоста.
	 * В процессе выполнения метод запускает отдельный поток, и возвращает управление вызвавшему
	 * коду.
	 * Для ожидания завершения работы сетевого соединения предназначен метод join().
	 * Перед вызовом метода можно задать имя файла для записи входящих данных,
	 * установить режим повторного установления соединения (если необходимо),
	 * установить таймаут автоматического разрыва соединения при отсутствии передачи или
	 * приема данных (значение по умолчанию 0 - соединение поддерживается бесконечно долго).
	 */
	virtual void run_async();

	/**
	 * @brief
	 * Старт сетевого подключения.
	 * Устанавливает соединение с указанным хостом при работе в режиме клиента, или ожидает
	 * подключения клиента на указанном порту при работе в режиме хоста.
	 * После установления соединения начинает работу цикл чтения порций приходящих через сетевое
	 * соединение данных, запись их в указанный файл, и передача их переопределеному методу
	 * класса-потомка.
	 * При завершении или разрыве соединения, если не активирован режим автоматического
	 * установления повторного соединения, цикл завершает работу. Если активирован режим
	 * повторного соединения, предпринимается попытка повторного подключения в режиме клиента,
	 * или переход в режим ожидания подключения в режиме хоста.
	 * Метод возвращает управление, когда цикл чтения данных из сетевого соединения звершит работу.
	 * Перед вызовом метода можно задать имя файла для записи входящих данных,
	 * установить режим повторного установления соединения (если необходимо),
	 * установить таймаут автоматического разрыва соединения при отсутствии передачи или
	 * приема данных (значение по умолчанию 0 - соединение поддерживается бесконечно долго).
	 */
	virtual void run();

	/**
	 * @brief
	 * Сообщает экземпляру класса о необходимости остановить работу.
	 * Не гарантирует остановки после возвращения управления.
	 * Остановки работы необходимо дождаться с помощью метода join().
	 * Не предназначен для вызова из обработчика системных сигналов SIGINT, SIGTERM при
	 * использовании метода run(), но может использоваться таким образом
	 * при использовании метода run_async().
	 * Не предназначен для вызова в том же потоке, в котором выполнен вызов run().
	 * В этом случае возможна бесконечная блокировка выполнения.
	 */
	virtual void stop();

	/**
	 * @brief
	 * Блокирует вызвавший поток. Возвращает управление после того, как объект класса
	 * завершит работу цикла чтения входящих данных, закроет сетевое соединение и
	 * уничтожит рабочий поток.
	 */
	virtual void join();

	/**
	 * @brief
	 * Подготовка к повторному запуску.
	 * Сбрасывает внутренние флаги.
	 * Используется перед повторным запуском run() или run_async().
	 * Не заменяет метод stop(). Остановка работающего в асинхронном режиме экземпляра
	 * класса должна быть выполнена методом stop(), с последующим ожиданием
	 * завершения работы методом join().
	 * Не влияет на следющие установки:
	 * - файл для записи лога входящих данных;
	 * - режим повторного утсановления соединения.
	 */
	virtual void reset();

	/**
	 * @brief
	 * Проверяет, находится ли объект класса в рабочем состоянии, или завершил работу.
	 * @return Состояние объекта класса: true - работает; false - работа завершена.
	 */
	virtual bool is_run() const;

	/**
	 * @brief
	 * Проверяет, находится ли объект класса в состоянии установленного сетевого соединения.
	 * @return Состояние соединения: true - идет обмен данными; false - нет сетевого соединения.
	 */
	virtual bool is_connected() const;

	virtual bool possible_need_restart() const;

	virtual bool is_live_stream() const;

	virtual bool is_idle() const;

	/**
	 * @brief
	 * Устанавливает время таймаута, через которое соединение будет разорвано в случае
	 * неактивности сетевого соединения.
	 * 0 - не разрывать соединение при отсутствии сетевой активности.
	 * Установка по умолчанию - соединение не разрывается.
	 * @param _timeout_ms Время таймаута, миллисекунд.
	 */
	virtual void set_timeout(uint64_t _timeout_ms);

	/**
	 * @brief Устанавливает флаг повторного установления соединения.
	 * @param _auto_reconnect [in] true - включить режим автоматического повторного
	 * установления соединения; false - выключить.
	 */
	virtual void set_reconnection_mode(bool _auto_reconnect);

	/**
	 * @brief Включает или отключает режим перехвата системных сигналов классом.
	 * Режим обработки сигналов SIGTERM и SIGINT предназначен для использования совместно
	 * с методом run() в главном потоке процесса. Не предназначен для использования
	 * с методом run_async().
	 * @param _handle_signals [in] true - включить режим перехвата сигналов;
	 * false - выключить (режим по умолчанию).
	 */
	virtual void set_handle_signals_mode(bool _handle_signals);

	/**
	 * @brief
	 * Включение или выключение записи (логирования) входящих данных в файл.
	 * Используется после создания объекта класса. Нельзя использовать во время работы
	 * основного цикла, после вызова run() или run_async().
	 * Если имя файла задано и файл удалось открыть, входящие через сетевое соединение
	 * данные записываются в файл.
	 * Если имя файла - пустая строка, запись отключается.
	 * Если открыть файл не удалось, генерируется исключение.
	 * @param _file_name [in] Имя файла. Если имя файла - пустая строка, запись в файл отключается.
	 * @param _erase [in] true - перед началом записи файл очищается (однократно, при вызове
	 * run() или run_async()). false - входящие данные дописываются к уже записанным в файл.
	 */
	virtual void set_raw_log_file(const std::string & _file_name, bool _erase = true);

	enum class ErrorStatus
	{
		OK, IDLE, IO_ERROR, CONNECT_ERROR, CONNECT_ABORT, CONNECT_TIMEOUT,
		SIGNAL_ERROR, APP_ERROR
	};
	static std::map<ErrorStatus, std::string> error_desc;

	std::string get_error_status() const;

	/**
	 * @brief Возвращает сообщение о последней ошибке,
	 * чтобы можно было вывести в лог осмысленную информацию
	 */
	std::string get_error_message();

protected:
	static const uint64_t EMPTY_TIMER_HANDLE = 0;

	/**
	 * @brief
	 * Вызывается перед тем, как будет произведена попытка установления соединения,
	 * или переход в режим ожидания подключения клиента. Все внутренние объекты
	 * класса в этот момент созданы и готовы к работе, но соединение еще не установлено.
	 * Может быть переопределен классом-потомком для выполнения действий,
	 * которые должны быть осуществленны перед каждым новым соединением.
	 * Потомки должны делать вызов ParenClass::on_before_new_connection() в начале метода.
	 */
	virtual void on_before_new_connection();

	/**
	 * @brief
	 * Вызывается после того, как успешно установлено новое соединение, и класс готов к
	 * приему и передаче данных.
	 * Потомки должны вызывать ParenClass::on_new_connection() в начале метода.
	 */
	virtual void on_new_connection();

	/**
	 * @brief
	 * Вызывается после того, как сетевое соединение закрыто, но до уничтожения внутренних
	 * объектов класса. Вызывается только в том случае, если было установлено соединение.
	 * Потомки должны вызывать ParenClass::on_close_connection() в конце метода.
	 */
	virtual void on_close_connection();

	/**
	 * @brief
	 * Вызывается после закрытия соединения или после неудачной попытки соединения.
	 * Вызывается всегда, как парный для on_before_new_connection().
	 * Потомки должны вызывать ParenClass::on_session_end() в конце метода.
	 */
	virtual void on_session_end();

	/**
	 * @brief
	 * Класс-потомок должен переопределить данный метод, в котором необходимо возвращать
	 * указатель на буфер, в который будут помещены принятые данные, когда они поступят,
	 * и максимальный размер буфера. Количество данных, которые будут помещены
	 * в буфер, может быть меньше, чем максимальный размер буфера.
	 * Вызывается каждый раз перед тем, как класс переходит к ожиданию получения порции данных
	 * через сетевое соединение. Данные будут помещены в указаный буфер.
	 * Класс - потомок должен переопределить метод в секции private.
	 * @param buffer [out] указатель на буфер.
	 * @param size [out] максимальный размер буфера.
	 * @return true, если буфер предоставлен. false, если буфер не может быть
	 * выделен, и работу необходимо завершить.
	 */
	virtual bool on_request_buffer(void * & buffer, size_t & size) = 0;

	/**
	 * @brief
	 * Вызывается каждый раз, когда из сетевого соединения прочитана очередная порция данных,
	 * и помещена в буфер, который был указан в методе on_request_buffer().
	 * Класс - потомок должен переопределить метод в секции private.
	 * @param buffer [in] указатель на полученные из сокета данные.
	 * @param octets [in] размер полученных данных, а байтах.
	 */
	virtual void on_read_socket(const void * buffer, size_t octets);

	/**
	 * @brief
	 * Отправляет через сетевое соединение порцию данных.
	 * Возвращает управление, не дожидаясь отправки данных. Область памяти, содержащая
	 * данные, должна существовать и содержать корректные данные до момента, когда
	 * будет вызван обработчик события завершения асинхронной передачи данных.
	 * Предназначен для вызова методами классов-потомков в том же потоке, в
	 * котором работает главный цикл.
	 * Не предназначен для вызова вне методов классов-потомков и из другого потока.
	 * @param buffer [in] Указатель на данные, которые необходимо передать.
	 * @param octets [in] Размер данных для передачи, байт.
	 */
	virtual void async_send_data(const void * buffer, size_t octets);

	/**
	 * @brief
	 * Отправляет через сетевое соединение порцию данных.
	 * Возвращает управление, когда все данные будут переданы сетевому стеку.
	 * В случае ошибки генерирует исключение.
	 * Предназначен для вызова методами классов-потомков в том же потоке, в
	 * котором работает главный цикл.
	 * Не предназначен для вызова вне методов классов-потомков и из другого потока.
	 * @param buffer [in] Указатель на данные, которые необходимо передать.
	 * @param count_in_bytes [in] Размер данных для передачи, байт.
	 */
	virtual void send_data(const void * buffer, size_t octets);

	/**
	 * @brief
	 * Вызывается каждый раз, когда завершилась асинхронная операция отправки
	 * порции данных через сетевое соединение.
	 * @param octets_transferred [in] Количество данных, которое было отправлено, байт.
	 * @param octets_required [in] Количество данных, которое требовалось отправить.
	 */
	virtual void on_async_data_sended(size_t octets_transferred, size_t octets_required);

protected:
	/**
	 * @brief
	 * Завершение работы рабочего потока и освобождение ресурсов. Предназначен
	 * для вызова в деструкторах производных классов.
	 */
	void shutdown();

	/**
	 * @brief
	 * Прерывает сессию сетевого соединения.
	 */
	void close_current_session();

	/**
	 * @brief
	 * Полность останавливает работу класса (завершает текущую сессию и останавливает цикл
	 * перезапуска новых сессий, если установлен флаг автоматического установления соединения).
	 */
	void stop_work();

	/**
	 * @brief
	 * Создает новый таймер, и возвращает его дескриптор.
	 * @return Дескриптор таймера.
	 */
	uint64_t create_timer();

	/**
	 * @brief
	 * Удаляет таймер с указанным дескриптором.
	 * Если указанного таймера не существует, вызывает исключение.
	 * @param handle [in] Дескриптор таймера.
	 */
	void remove_timer(uint64_t handle);

	/**
	 * @brief
	 * Удаляет все таймеры.
	 */
	void remove_all_timers();

	void cancel_all_timers();

	/**
	 * @brief
	 * Перезапускает указанный таймер.
	 * Если указанного таймера не существует, вызывает исключение.
	 * @param handle [in] Дескриптор таймера.
	 * @param timeout_ms [in] Время до срабатывания таймера, миллисекунд.
	 */
	void restart_timer(uint64_t handle, int64_t timeout_ms);

	/**
	 * @brief
	 * Вызывается при срабатывании одного из таймеров.
	 * @param handle [in] Дескриптор таймера.
	 */
	virtual void on_timer(uint64_t handle);

	void update_live_timestamp();

	void set_error_status(const ErrorStatus, const std::string & err_message);

	void reset_error_status();

	void set_ok_status();

	void new_accept(); // TODO удалить как устаревшее

private:
	/**
	 * @brief
	 * Функция обратного вызова - обработчик события приема подключения от клиента.
	 * @param ec [in] Код ошибки.
	 * Документация: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html
	 */
	void asio_accept_handler(const boost::system::error_code & ec);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события установления соединения с хостом.
	 * @param ec [in] Код ошибки.
	 * Документация: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html
	 */
	void asio_connect_handler(const boost::system::error_code & ec);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события чтения порции данных из сокета.
	 * @param ec [in] Код ошибки.
	 * @param octets_transferred [in] Количество байт данных, прочитанных
	 * из сокета. Данные находятся в буфере, который был указан при вызове
	 * метода асинхронного чтения данных.
	 * Документация: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html
	 */
	void asio_read_handler(const boost::system::error_code & ec,
	                       size_t octets_received);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события записи порции данных в сокет.
	 * @param ec [in] Код ошибки.
	 * @param octets_transferred [in] Количество байт данных, записанных в сокет.
	 * @param octets_required [in] Количество байт данных, переданных методу асинхронной
	 * записи данных в сокет.
	 * Документация: http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html
	 */
	void asio_write_handler(const boost::system::error_code & ec,
	                        size_t octets_transferred,
	                        size_t octets_required);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик системных сигналов SIGINT, SIGTERM.
	 * Если активирован режим обработки сигналов, используется
	 * классом для корректной остановки цикла чтения входящих данных и завершения работы.
	 * @param ec [in] Код ошибки.
	 * @param signal_number [in] Код сигнала.
	 */
	void asio_signal_handler(const boost::system::error_code & ec, int signal_number);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик события таймаута таймера активности соединения.
	 * @param ec [in] Код ошибки.
	 */
	void asio_iddle_timer_handler(const boost::system::error_code & ec);

	/**
	 * @brief
	 * Функция обратного вызова - обработчик событий таймаута таймеров.
	 * @param handle [in] Дескриптор таймера.
	 */
	void timers_handler(uint64_t handle);

private:
	/**
	* @brief
	* Перезапускает таймер, отсчитывающий таймаут неактивности соединения.
	*/
	void restart_iddle_timer();

	/**
	 * @brief
	 * Подключает таймеры к объекту типа boost::asio::io_service.
	 * @param _io_service [in] Сервис, к которому подключаются таймеры.
	 */
	void attach_timers_to_io_service();

	/**
	 * @brief
	 * Отключает таймеры от объекта типа boost::asio::io_service.
	 */
	void detach_timers_from_io_service();

	/**
	 * @brief
	 * Открывает файл для записи входящих данных, если его имя задано.
	 * Генерирует исключение при ошибке.
	 */
	void open_log_file();

	/**
	* @brief
	* Записывает порцию данных из буфера в файл, заданный вызовом метода set_raw_log_file().
	* @param buffer [in] Указатель на данные для записи в файл.
	* @param octets [in] Размер данных для записи, в байтах.
	*/
	void write_buffer_to_log_file(const void * buffer, size_t octets);

	/**
	* @brief
	* Запускает асинхронную операцию ожидания поступления данных через соединение.
	* Получает у класса-потомка буфер для данных с помощью метода on_request_buffer(),
	* после чего стартует асинхронную операцию чтения и возвращает управление.
	* Когда данные поступят, они будут помещены в указанный буфер, после чего будет вызван
	* метод on_read_socket().
	*/
	void async_read_some_from_socket();

	/**
	* @brief
	* Настраивает перехват системных сигналов.
	*/
	void attach_signal_handlers_to_io_service();

	/**
	* @brief
	* Подготавливает ресурсы к сессии сетевого соединения.
	*/
	void setup_session_resources();

	/**
	* @brief
	* Осбобождает ресурсы после сессии сетевого соединения.
	*/
	void cleanup_session_resources();

	/**
	* @brief
	* Размещает в очереди задач задачу на установление соединения при старте
	* объекта io_service.
	*/
	void post_connection_task_to_io_service();

	/**
	 * @brief
	 * Останавливает работу объекта io_service (прерывает цикл сетевого обмена данными).
	 */
	void stop_io_service();

	/**
	* Основной цикл рабочего потока.
	* Устанавливает соединение в режиме клиента с указанным хостом либо
	* ожидает и устанавливает соединение с клиентом на указанном порту в режиме хоста,
	* запускает цикл чтения входящих данных из сокета.
	* Если установлен режим повторного установления соединения, после закрытия
	* текущего соединения или ошибки сети пытается установить новое подключение или
	* переходит в режим ожидания подключения клиента.
	*/
	void main_loop();

	/**
	* @brief
	* Метод для запуска в отдельном рабочем потоке. Вызывает main_loop() и
	* перехватывает исключения.
	*/
	void async_loop();

private:
	/**
	 * @brief
	 * Пауза перед повторным установлением соединения, миллисекунд.
	 * Предотвращает загрузку ядра процессора при проблемах сетевого стека.
	 */
	const int64_t CPU_PREVENT_OVERLOAD_TIMEOUT_MS = 100;

protected:
	uint16_t port;
	std::string ip;
	std::string raw_log_file_name;

private:
	bool erase_raw_log_file;
	bool first_connection;

	int64_t iddle_timeout_ms;

	void * read_buffer;
	size_t read_buffer_size;

	std::atomic<bool> full_stop_flag;
	std::atomic<bool> is_run_flag;
	std::atomic<bool> is_connected_flag;
	std::atomic<bool> session_stop_flag;
	std::atomic<bool> reconnection_flag;
	std::atomic<bool> handle_signals;
	std::atomic<bool> is_clean_to_run;
	std::atomic<bool> shutdown_flag;

	std::mutex session_resources_mutex;

	std::unique_ptr<std::thread> async_thread;
	std::unique_ptr<boost::asio::io_service> io_service;
	std::unique_ptr<boost::asio::signal_set> system_signals;
	std::unique_ptr<boost::asio::deadline_timer> iddle_timer;
	std::unique_ptr<boost::asio::ip::tcp::socket> socket;
	std::unique_ptr<boost::asio::ip::tcp::endpoint> endpoint;
	std::unique_ptr<boost::asio::ip::tcp::acceptor> acceptor;
	std::unique_ptr<std::ofstream> raw_log_file;

	std::list<AsioTimer> timers;

private:
	static const int64_t STARTUP_TIMEOUT = 60000; // 60 секунд для получения первого пакета
	static const int64_t LIVE_TIMEOUT = 45000; // 45 секунд для ожидания следующего пакета

	std::atomic_int_fast64_t start_timestamp; // момент старта соединения
	std::atomic_int_fast64_t last_live_timestamp; // момент получения последнего пакета
	std::atomic_bool live_flag; // устанавливается в true, если получен хотя бы один пакет
	std::atomic_bool start_flag; // устанавливается в момент старта работы класса
	std::atomic_bool idle_flag {true}; // устройство не выполняет полезной работы

protected:
	bool new_accept_flag; // установить новый акцепт без перезагрузки сервиса

protected:
	std::string error_message;
	std::mutex error_message_mutex;
	std::atomic<bool> error_flag;
	std::atomic<ErrorStatus> error_status;
};

#endif // NETWORKCONNECTION_HPP
